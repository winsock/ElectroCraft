.data
name db "CeriOS v1.0", 0
bootMsg db "Loading CeriOS", 0
bootupChar db ".", 0
welcomeMessage db "Welcome to CeriOS", 0xA, "A Minecraft operating system written by Andrew Querol", 0xA, "To get started type help", 0
promptChar db "> ", 0
shutdownMessage db "Goodbye!", 0

; Command buffer
cmdBuffer db ? 255 ; Stores the command in a 255 byte buffer
cmdArgsBuffer db ? 255 ; A buffer to store the arguments seperated by null charaters
terminalBufferRow dd ? 1 ; The current row we are in
terminalBufferCol dd ? 1 ; The current column we are in
terminalBufferSize dd ? 1 ; Make room for the display buffer size

; Commands
cmdHelp db "help", 0
helpMsg db "Command - Description", 0xA, "ls - Lists files", 0xA, "echo - Prints inputed text", 0xA, "shutdown - Shutsdown the computer", 0xA, "edit - Creates or edits a text file", 0xA, "rm - Removes a directory", 0xA, "rmdir - Removes a directory", 0xA, "cp - Copies a file", 0xA, "cd - Changes directories", 0xA, "mkdir - Creates a directory", 0xA, "clear - Clears the screen", 0xA, "time - Prints the curent time", 0

cmdList db "ls", 0
cmdEcho db "echo", 0
cmdShutdown db "shutdown", 0
cmdEdit db "edit", 0
cmdRemove db "rm", 0
cmdRemoveDir db "rmdir", 0
cmdCopy db "cp", 0
cmdChangeDir db "cd", 0
cmdMakeDir db "mkdir", 0
cmdClear db "clear", 0
cmdTime db "time", 0

.code
xor ecx, ecx ; Clear ecx
xor ebx, ebx ; Clear ebx
mov terminalBufferRow, 0 ; Set the display buffer row to 0 on startup
mov terminalBufferCol, 0 ; Set the display buffer column to 0 on startup
mov terminalBufferSize, [0x12C11] ; Move the number of coloumns into te Termainal Memory starts at 0x12C11
mul [terminalBufferSize], [0x12C15] ; Multiply by the number of rows

; Display the boot message
push bootMsg ; Push the address of the boot mesage on the stack (The argument)
call displayNullTerminatedString ; Call the display method
add esp, 4 ; Dump the old argument

mov cx, 20 ; Set up the loop counter, loop twenty times before finish booting
startupLoop:
push bootupChar ; Push the address of the bootup char
call displayNullTerminatedString ; Display it
add esp, 4 ; Dump the old argument
sleep 30 ; Sleep 10 ms
loop startupLoop ; Loop until twenty is reached
xor ecx, ecx ; Clear the counter
call clearTerminal ; Clear the terminal

push welcomeMessage ; Push the welcome message address
call displayNullTerminatedString ; Display the welcome message
add esp, 4 ; Dump the old contents of the argument
; Add a line after the welcome screen
add dword [terminalBufferRow], 1
mov terminalBufferCol, 0
; Show the prompt char
push promptChar
call displayNullTerminatedString
add esp, 4

mainLoop:
sub esp, 4 ; Allocate 4 bytes to get keyboardInput
call keyboardInput ; Gets the nex char inputed, blocks till a key is pressed
pop eax ; Get the character that was returned

cmp byte eax, 0x8 ; Lets see if its a backspace
jne doDisplayChar ; Its not a backspace skip this section
sub dword [terminalBufferCol], 1 ; Remove one from the column
sub ecx, 1 ; Deincrement out key buffer counter
mov eax, 0 ; Move into eax the null char

doDisplayChar:
; Push the char into our buffer
push ecx
add ecx, cmdBuffer
mov byte [ecx], eax
mov ebx, cmdBuffer
mov byte eax, [ecx]
pop ecx
; Display the character
add dword [terminalBufferCol], 1 ; Increment the column we are in
cmp dword [terminalBufferCol], [0x12C11] ; Compare it to the max number
je resetCharCounter ; If we have reached the max number reset the counter
mov ebx, [0x12C11] ; Move the number of columns into ebx
mul ebx, [terminalBufferRow] ; Multiply it by the curent row
add ebx, [terminalBufferCol] ; Add the curent columns to the result
cmp ebx, [terminalBufferSize] ; Check if it is at the end of the buffer
jg haltCpu ; For now just reset the char counter
je haltCpu
add dword ebx, [0x12C19] ; And finally add the base offset to the calculated offset
mov byte [ebx], eax ; Finally put the byte value of the character into the buffer

; Incremnt and check our counters
add ecx, 1 ; Increment our key buffer counter
cmp ecx, 255 ; Did we reach out max buffer size?
je resetCharCounter ; If so clear it by jumping past the get command stuff

cmp byte eax, 0xA ; Is it enter?
jne mainLoop ; If it isn't enter continue getting keys until enter is pressed or we reach 255 chars

mov byte [ebx], 0 ; Remove the enter char

; Add the null terminating char to the cmd buffer while removing the enter char
push ecx
sub ecx, 1
add ecx, cmdBuffer
mov byte [ecx], 0
pop ecx

add [terminalBufferRow], 1 ; Increment the rows
mov terminalBufferCol, 0 ; Reset the position in the columns

strcmp cmdBuffer, cmdHelp
jne checkLs
push helpMsg
call displayNullTerminatedString
int 4096
jmp resetCharCounter

checkLs:
strcmp cmdBuffer, cmdList
jne checkEcho
jmp resetCharCounter

checkEcho:
strcmp cmdBuffer, cmdEcho
jne checkShutdown
jmp resetCharCounter

checkShutdown:
strcmp cmdBuffer, cmdShutdown
jne checkEdit
jmp haltCpu

checkEdit:
strcmp cmdBuffer, cmdEdit
jne checkRemove
jmp resetCharCounter

checkRemove:
strcmp cmdBuffer, cmdRemove
jne checkRemoveDir
jmp resetCharCounter

checkRemoveDir:
strcmp cmdBuffer, cmdRemoveDir
jne checkCopy
jmp resetCharCounter

checkCopy:
strcmp cmdBuffer, cmdCopy
jne checkChangeDir
jmp resetCharCounter

checkChangeDir:
strcmp cmdBuffer, cmdChangeDir
jne checkMakeDir
jmp resetCharCounter

checkMakeDir:
strcmp cmdBuffer, cmdMakeDir
jne checkClear
jmp resetCharCounter

checkClear:
strcmp cmdBuffer, cmdClear
jne checkTime
call clearTerminal
jmp resetCharCounter

checkTime:
strcmp cmdBuffer, cmdTime
jne resetCharCounter

resetCharCounter:
; Add a line after the command
add dword [terminalBufferRow], 1
mov terminalBufferCol, 0
; Show the prompt char
push promptChar
call displayNullTerminatedString
add esp, 4
xor ecx, ecx ; Clear ecx(The counter) because enter was pressed
jmp mainLoop ; And repeat


;
; Clears the terminal
;
clearTerminal:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax
mov ecx, [terminalBufferSize]

; Clear the buffer
clearLoop:
xor eax, eax
add eax, ecx
add eax, [0x12C19]
mov [eax], 0
loop clearLoop

; Reset the counters
mov [terminalBufferCol], 0
mov [terminalBufferRow], 0

pop eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return

;
; Gets the next char from the keyboard
;
keyboardInput:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Push the old value of eax onto the stack
getChar:
inp eax, 0x122 ; Get the next character from the keyboard buffer
cmp eax, 0 ; Is it a null char?
je getChar ; If it is try again
mov [ebp + 8], eax ; Else move it into the first argument spot(The return value)
pop eax ; Pop the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Dispalys a null terminated string to the terminal
;
displayNullTerminatedString:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Store the old value of eax
push ebx ; store the old value of ebx
push ecx ; Store the old value of ecx
xor ecx, ecx ; Clear ecx
mov eax, [ebp + 8] ; Move the address of the string into eax

; The display loop
displayLoop:
; Get the new offset
mov ecx, dword [0x12C11] ; Move into ecx the number of columns
mul ecx, dword [terminalBufferRow] ; Multiply into ecx the curent row we are in
add ecx, dword [terminalBufferCol] ; Add the curent column we are in

; Comparisons
cmp ecx, dword [terminalBufferSize] ; Lets check if its at the end of the display buffer
jg haltCpu
je haltCpu
cmp byte [eax], 0xA ; Lets see if it is an enter
je onEnterPress ; If its enter lets do special stuff for it
cmp byte [eax], 0 ; Lets see if it's the null terminator
je displayEnd ; Jump to the end of the sub routine

; Actual writing to the display buffer
mov ebx, dword [0x12C19] ; The value at this location is the start address of the terminal buffer, usually just the next four bytes
add ebx, ecx ; Add the curent offset to the base address
mov byte [ebx], [eax] ; Move the char into the terminal buffer

; Incrementing
add [terminalBufferCol], 1 ; Increment the display offset
add eax, 1 ; Increment the offset in the string
jmp displayLoop

; Enter handling
onEnterPress:
add eax, 1 ; Increment the string offset
add [terminalBufferRow], 1 ; Add one to the row counter
mov terminalBufferCol, 0 ; Rest the column counter
jmp displayLoop ; Jump back to display more characters

; The end of the display string function
displayEnd:
pop ecx ; Retreive the old value of ecx
pop ebx ; Restore the old value of ebx
pop eax ; Retreive the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Stops the computer, currently only gets called on shutdown
;
haltCpu:
push shutdownMessage ; Push the shutdown message
call displayNullTerminatedString ; Call display string
add esp, 4 ; Discard the result
sleep 20 ; sleep for 20ms
hlt ; This opcode halts(Shutsdown) the cpu