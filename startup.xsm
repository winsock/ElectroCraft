.data
name db "CeriOS v1.0", 0
bootMsg db "Loading CeriOS", 0
bootupChar db ".", 0
welcomeMessage db "Welcome to CeriOS", 0xA, "A Minecraft operating system written by Andrew Querol", 0xA, "To get started type help", 0
promptChar db "> ", 0
shutdownMessage db "Goodbye!", 0

; Command buffer
cmdBuffer db ? 1024 ; Stores the command in a 255 byte buffer
cmdArgsBuffer db ? 1024 ; A buffer to store the arguments seperated by null charaters
terminalBufferRow dd ? 1 ; The current row we are in
terminalBufferCol dd ? 1 ; The current column we are in
terminalBufferSize dd ? 1 ; Make room for the display buffer size

; Commands
cmdHelp db "help", 0
helpMsg db "Command - Description", 0xA, "ls - Lists files", 0xA, "echo - Prints inputed text", 0xA, "shutdown - Shutsdown the computer", 0xA, "edit - Creates or edits a text file", 0xA, "rm - Removes a directory", 0xA, "rmdir - Removes a directory", 0xA, "cp - Copies a file", 0xA, "cd - Changes directories", 0xA, "mkdir - Creates a directory", 0xA, "clear - Clears the screen", 0xA, "time - Prints the curent time", 0

cmdList db "ls", 0
cmdEcho db "echo", 0
cmdShutdown db "shutdown", 0
cmdEdit db "edit", 0
cmdRemove db "rm", 0
cmdRemoveDir db "rmdir", 0
cmdCopy db "cp", 0
cmdChangeDir db "cd", 0
cmdMakeDir db "mkdir", 0
cmdClear db "clear", 0
cmdTime db "time", 0

.code
xor ecx, ecx ; Clear ecx
xor ebx, ebx ; Clear ebx
mov terminalBufferRow, 0 ; Set the display buffer row to 0 on startup
mov terminalBufferCol, 0 ; Set the display buffer column to 0 on startup
mov terminalBufferSize, [0x12C11] ; Move the number of coloumns into te Termainal Memory starts at 0x12C11
mul [terminalBufferSize], [0x12C15] ; Multiply by the number of rows

; Display the boot message
push bootMsg ; Push the address of the boot mesage on the stack (The argument)
call displayNullTerminatedString ; Call the display method
add esp, 4 ; Dump the old argument

mov cx, 20 ; Set up the loop counter, loop twenty times before finish booting
startupLoop:
push bootupChar ; Push the address of the bootup char
call displayNullTerminatedString ; Display it
add esp, 4 ; Dump the old argument
sleep 30 ; Sleep 10 ms
loop startupLoop ; Loop until twenty is reached
xor ecx, ecx ; Clear the counter
call clearTerminal ; Clear the terminal

push welcomeMessage ; Push the welcome message address
call displayNullTerminatedString ; Display the welcome message
add esp, 4 ; Dump the old contents of the argument
; Add a line after the welcome screen
add dword [terminalBufferRow], 1
mov terminalBufferCol, 0
; Show the prompt char
push promptChar
call displayNullTerminatedString
add esp, 4

mainLoop:
sub esp, 4 ; Allocate 4 bytes to get keyboardInput
call keyboardInput ; Gets the nex char inputed, blocks till a key is pressed
pop eax ; Get the character that was returned

cmp byte eax, 0x8 ; Lets see if its a backspace
jne doDisplayChar ; Its not a backspace skip this section
sub dword [terminalBufferCol], 1 ; Remove one from the column
sub ecx, 1 ; Deincrement out key buffer counter
mov eax, 0 ; Move into eax the null char

doDisplayChar:
; Push the char into our buffer
push ecx
add ecx, cmdBuffer
mov byte [ecx], eax
mov ebx, cmdBuffer
mov byte eax, [ecx]
pop ecx
; Display the character
add dword [terminalBufferCol], 1 ; Increment the column we are in
cmp dword [terminalBufferCol], [0x12C11] ; Compare it to the max number
je resetCharCounter ; If we have reached the max number reset the counter
mov ebx, [0x12C11] ; Move the number of columns into ebx
mul ebx, [terminalBufferRow] ; Multiply it by the curent row
add ebx, [terminalBufferCol] ; Add the curent columns to the result
cmp ebx, [terminalBufferSize] ; Check if it is at the end of the buffer
jg haltCpu ; For now just reset the char counter
je haltCpu
add dword ebx, [0x12C19] ; And finally add the base offset to the calculated offset
mov byte [ebx], eax ; Finally put the byte value of the character into the buffer

; Incremnt and check our counters
add ecx, 1 ; Increment our key buffer counter
cmp ecx, 255 ; Did we reach out max buffer size?
je resetCharCounter ; If so clear it by jumping past the get command stuff

cmp byte eax, 0xA ; Is it enter?
jne mainLoop ; If it isn't enter continue getting keys until enter is pressed or we reach 255 chars

mov byte [ebx], 0 ; Remove the enter char

; Add the null terminating char to the cmd buffer while removing the enter char
push ecx
sub ecx, 1
add ecx, cmdBuffer
mov byte [ecx], 0
pop ecx

add [terminalBufferRow], 1 ; Increment the rows
mov terminalBufferCol, 0 ; Reset the position in the columns

push 0x20
sub esp, 4
push cmdArgsBuffer
push cmdBuffer
call explodeString
add esp, 8 ; Remove the last argument
pop eax ; Get the third argument
add esp, 4 ; Remove the rest

strcmp cmdArgsBuffer, cmdHelp
jne checkLs
push helpMsg
call displayNullTerminatedString
int 4096
jmp resetCharCounter

checkLs:
strcmp cmdArgsBuffer, cmdList
jne checkEcho
jmp resetCharCounter

checkEcho:
strcmp cmdArgsBuffer, cmdEcho
jne checkShutdown
cmp eax, 1
jl checkShutdown
push 1
push cmdArgsBuffer
call getStringOffset
add esp, 4
pop eax
bkp
add eax, cmdArgsBuffer
bkp
push eax
call displayNullTerminatedString
add esp, 4
jmp resetCharCounter

checkShutdown:
strcmp cmdArgsBuffer, cmdShutdown
jne checkEdit
jmp haltCpu

checkEdit:
strcmp cmdArgsBuffer, cmdEdit
jne checkRemove
jmp resetCharCounter

checkRemove:
strcmp cmdArgsBuffer, cmdRemove
jne checkRemoveDir
jmp resetCharCounter

checkRemoveDir:
strcmp cmdArgsBuffer, cmdRemoveDir
jne checkCopy
jmp resetCharCounter

checkCopy:
strcmp cmdArgsBuffer, cmdCopy
jne checkChangeDir
jmp resetCharCounter

checkChangeDir:
strcmp cmdArgsBuffer, cmdChangeDir
jne checkMakeDir
jmp resetCharCounter

checkMakeDir:
strcmp cmdArgsBuffer, cmdMakeDir
jne checkClear
jmp resetCharCounter

checkClear:
strcmp cmdArgsBuffer, cmdClear
jne checkTime
call clearTerminal
jmp resetCharCounter

checkTime:
strcmp cmdArgsBuffer, cmdTime
jne resetCharCounter

resetCharCounter:
; Add a line after the command
add dword [terminalBufferRow], 1
mov terminalBufferCol, 0
; Show the prompt char
push promptChar
call displayNullTerminatedString
add esp, 4
xor ecx, ecx ; Clear ecx(The counter) because enter was pressed
jmp mainLoop ; And repeat


;
; Clears the terminal
;
clearTerminal:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax
mov ecx, [terminalBufferSize]

; Clear the buffer
clearLoop:
xor eax, eax
add eax, ecx
add eax, [0x12C19]
mov [eax], 0
loop clearLoop

; Reset the counters
mov [terminalBufferCol], 0
mov [terminalBufferRow], 0

pop eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return

;
; Gets the next char from the keyboard
;
keyboardInput:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Push the old value of eax onto the stack
getChar:
inp eax, 0x122 ; Get the next character from the keyboard buffer
cmp eax, 0 ; Is it a null char?
je getChar ; If it is try again
mov [ebp + 8], eax ; Else move it into the first argument spot(The return value)
pop eax ; Pop the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Splits a string by the specified delim in arg 4, arg 1 is the address of the string
; arg 2 is the address to store the results in, arg 3 is where the number of results is stored
; [epb + 8] = arg1, [ebp + 12] = arg2, [ebp + 16] = arg3, [ebp + 20] = arg4
;
explodeString:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push ecx ; Store the old value of ecx
push eax ; Store the old value of eax
push ebx ; Store the old value of ebx

xor ecx, ecx
xor eax, eax
xor ebx, ebx
mov [ebp + 16], 0

splitLoop:
mov ebx, [ebp + 12]
add ebx, ecx
mov eax, [ebp + 8]
add eax, ecx
cmp byte [eax], [ebp + 20]
jne splitLoopEnd

mov ebx, [ebp + 12]
add ebx, ecx
mov [ebx], 0
add ecx, 1
add [ebp + 16], 1
jmp splitLoop

splitLoopEnd:
mov [ebx], [eax]
add ecx, 1
cmp byte [eax], 0
jne splitLoop

pop ebx ; Restore ebx
pop eax ; Restore eax
pop ecx ; Restore ecx
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Returns the offset needed to access a string in a string array deliminated by null characters
; [ebp + 8] = String array, [ebp + 12] = requested number / return value
;
getStringOffset:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Store eax
push ebx ; Store ebx
push ecx ; Store ecx
push emc ; Store emc

xor eax, eax ; Clear eax
xor ebx, ebx ; Clear ebx
xor ecx, ecx ; Clear ecx
xor emc, emc ; Clear emc

offsetLoop:
mov eax, [ebp + 8]
add eax, ecx
cmp byte [eax], 0
jne offsetLoopEnd
cmp emc, 1
jg stringOffsetEnd
add ebx, 1
cmp ebx, [ebp + 12]
je stringOffsetEnd
add emc, 1
offsetLoopEnd:
add ecx, 1
mov emc, 0
jmp offsetLoop

stringOffsetEnd:
add ecx, 1
mov [ebp + 12], ecx
pop emc ; Restore emc
pop ecx ; Restore ecx
pop ebx ; Restore ebx
pop eax ; Restore eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Dispalys a null terminated string to the terminal
;
displayNullTerminatedString:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Store the old value of eax
push ebx ; store the old value of ebx
push ecx ; Store the old value of ecx
xor ecx, ecx ; Clear ecx
mov eax, [ebp + 8] ; Move the address of the string into eax

; The display loop
displayLoop:
; Get the new offset
mov ecx, dword [0x12C11] ; Move into ecx the number of columns
mul ecx, dword [terminalBufferRow] ; Multiply into ecx the curent row we are in
add ecx, dword [terminalBufferCol] ; Add the curent column we are in

; Comparisons
cmp ecx, dword [terminalBufferSize] ; Lets check if its at the end of the display buffer
jg haltCpu
je haltCpu
cmp byte [eax], 0xA ; Lets see if it is an enter
je onEnterPress ; If its enter lets do special stuff for it
cmp byte [eax], 0 ; Lets see if it's the null terminator
je displayEnd ; Jump to the end of the sub routine

; Actual writing to the display buffer
mov ebx, dword [0x12C19] ; The value at this location is the start address of the terminal buffer, usually just the next four bytes
add ebx, ecx ; Add the curent offset to the base address
mov byte [ebx], [eax] ; Move the char into the terminal buffer

; Incrementing
add [terminalBufferCol], 1 ; Increment the display offset
add eax, 1 ; Increment the offset in the string
jmp displayLoop

; Enter handling
onEnterPress:
add eax, 1 ; Increment the string offset
add [terminalBufferRow], 1 ; Add one to the row counter
mov terminalBufferCol, 0 ; Rest the column counter
jmp displayLoop ; Jump back to display more characters

; The end of the display string function
displayEnd:
pop ecx ; Retreive the old value of ecx
pop ebx ; Restore the old value of ebx
pop eax ; Retreive the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Stops the computer, currently only gets called on shutdown
;
haltCpu:
push shutdownMessage ; Push the shutdown message
call displayNullTerminatedString ; Call display string
add esp, 4 ; Discard the result
sleep 20 ; sleep for 20ms
hlt ; This opcode halts(Shutsdown) the cpu